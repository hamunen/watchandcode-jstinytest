<script src="../tinytest.js"></script>
<script>

/* Prototype:
function reduce(originalArray, callback, initialValue) {}
var resultSoFar = initialValue;
  for (var i = 0; i < originalArray.length; i++) {
    resultSoFar = callback(resultSoFar, originalArray[i], i, originalArray)
  }
  return resultSoFar;
}

The reduce() method executes a reducer function (that you provide) on each member of the array resulting in a single output value.

Function signature:
reduce(array, callback[, initialvalue])

Returns a single value.

Callback parameters:
- previousValue
- currentValue
- currentIndex
- array 

Requirements:
- It should actually reduce array to a single output value.
- Callback should not run on holes in the array

- If initialValue is provided
  - previousValue = initialValue
  - currentValue = first value in array
  - callback will start at index 0
- If initialValue not provided
  - previousValue = first value in array
  - currentValue = second value in array
  - callback will start at index 1

  Edge cases
  - If array is empty and no initialValue provided -> throw TypeError
  - If no initialValue and array has one element, return only element without calling callback
  - If initialValue and array is empty, return initialValue without calling callback
  */

function reduce(originalArray, callback, initialValue) {
  var startingIndex = 0;

  if(arguments.length < 3) {
    startingIndex++;
  }

  for(var i = startingIndex; i < originalArray.length; i++) {
    callback();
  }  
}

tests({
  'If initialValue, callback should run array.length times.': function () {
    var numberOfTimesCallbackRun = 0;
    reduce([1,2,3], function(previousValue) {
      numberOfTimesCallbackRun++;
    }, 0);
    eq(numberOfTimesCallbackRun,3);
  },
  'If no initialValue, callback should run array.length - 1 times.': function () {
    var numberOfTimesCallbackRun = 0;
    reduce([1,2,3], function(previousValue) {
      numberOfTimesCallbackRun++;
    });
    eq(numberOfTimesCallbackRun,2);
  },
  'If initialValue, previousValue should start with initialValue.': function () {
    reduce([1], function(previousValue) {
      eq(previousValue, 0);
    }, 0);
  },
  'If initialValue, currentValue should start with first element.': function () {fail();},
  'If initialValue, callback should start at index 0.': function () {fail();},

  'If no initialValue, previousValue should start with first element.': function () {fail();},
  'If no initialValue, currentValue should start with second element.': function () {fail();},
  'If no initialValue, callback should start at index 1.': function () {fail();},

  'If initialValue, and array is empty, return initialValue without calling callback.': function () {fail();},
  'If no initialValue, and array has one element, return that element without calling callback.': function () {fail();},

  'Should actually reduce.': function () {fail();},
  'Should exclude holes.': function () {fail();},
  'If array is empty, and no initialValue, throw TypeError.': function () {fail();},
  'Pass array as fourth argument to the callback.': function () {fail();}
});
</script>